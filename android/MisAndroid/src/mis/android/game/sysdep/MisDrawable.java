package mis.android.game.sysdep;

import java.util.ArrayList;
import java.util.List;

import javax.microedition.khronos.opengles.GL10;
import javax.microedition.khronos.opengles.GL11;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import android.content.Context;

/**
 * Class for drawing image using open GL. 
 * Each figure can have several drawables - to show.
 * Also put here for now 
 * @author misha
 *
 */
public abstract class MisDrawable extends Box {
	List<Point> pnts = new ArrayList<Point>();
    /** additional points to convert on turns */
    List<Point> apnts = new ArrayList<Point>();

    List<Triangle> tris = new ArrayList<Triangle>(); 
	public boolean useTextures = false;

	/** place from which we read files */
	public String fileName;	
	public String name;
	
	public MisDrawable() {
	}
    
    public List<Point> getApnts() {
        return apnts;
    }
    /**
     * turning 90 degrees clockwise
     */
    public void turn() {
        Point oldPos = new Point(0,0,0);
        oldPos.set(getPos());
        
        for (Point p : pnts) {
            int t = p.x;
            p.x = -p.y;
            p.y = t;
        }
        for (Point p : apnts) {
            int t = p.x;
            p.x = -p.y;
            p.y = t;
        }
        this.setSizes();
        this.pos.set(oldPos);
        this.fillBuffers();
    }
	
	/**
	 * read figure configuration from XML.
	 * We can read some configuration in MisFigure.
	 * Actual figure was generated by 
	 * Reading type and pos - anything else we read in derived classes.
	 * 
	 * @param node - XmlNode from which we read configuration
	 */
	public void readXml(Element el) {
		super.readXml(el);	
		this.name = el.getAttribute("name");
	}
	
	/**
	 * read additional data - such as figure construction from separate file
	 * or texture.
	 * Also generates points or texture for generated models
	 */
	public void fillData(Context context) {
	    // by default we do nothing
	}
	
	/**
	 * fill texture or buffers or arrays 
	 */
	public abstract void fillBuffers();
	
	public void clean() {
	    // do nothing
	}
	
	/**
	 * draw figure on GL11 surface.
	 */
	public abstract void draw(GL11 gl);
    
    /**
     * shift zero so 
     */
    protected void shiftZero(float dx, float dy, float dz) {
        for (Point p : pnts) {
            p.translate(dx, dy, dz);
        }
        for (Point p : apnts) {
            p.translate(dx, dy, dz);
        }
        pos.translate(-dx, -dy, -dz);        
    }
    
    public void setSizes() {
        int minX, minY, minZ;
        int maxX, maxY, maxZ;
        
        minX = minY = minZ = 10000  * Box.SCALE;
        maxX = maxY = maxZ = -10000  * Box.SCALE;
        
        for (Point p : pnts) {
            minX = Math.min(p.x, minX);
            minY = Math.min(p.y, minY);
            minZ = Math.min(p.z, minZ);
            maxX = Math.max(p.x, maxX);
            maxY = Math.max(p.y, maxY);
            maxZ = Math.max(p.z, maxZ);
        }
        sz.x = maxX - minX;
        sz.y = maxY - minY;
        sz.z = maxZ - minZ;
        this.shiftZero(-minX, -minY, -minZ);
    }
    
    public void copy(Box b) {
        super.copy(b);
        MisDrawable md = (MisDrawable)b;
        int np = pnts.size();
        int nt = tris.size();
        
        // copy pnts
        pnts.clear();
        for (int i=0; i < np; i++) {
            Point bp = md.pnts.get(i);
            Point p = new Point(bp.x, bp.y, bp.z);
            pnts.add(p);
        }
        // copy tris
        tris.clear();
        for (int i=0; i < nt; i++) {
            Triangle bt = md.tris.get(i);
            Triangle t = new Triangle(bt.a, bt.b, bt.c);
            tris.add(t);
        }
        this.fileName = md.fileName;
        this.useTextures = md.useTextures;
    }

}
