package mis.babylon.game.graphics;

import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Element;

import mis.android.utils.MisContext;
import mis.babylon.game.MisFigure;
import mis.babylon.game.MovableFigure;
import mis.babylon.opengl.sysdep.MisGL11;

/**
 * Class for drawing image using open GL. 
 * Each figure can have several drawables - to show.
 * Also put here for now 
 * @author misha
 *
 */
public abstract class MisDrawable extends Box {
    List<Point> pnts = new ArrayList<Point>();
    /** additional points to convert on turns */
    List<Point> apnts = new ArrayList<Point>();
    private MisContext myContext = null;

    List<Triangle> tris = new ArrayList<Triangle>(); 
	public boolean useTextures = false;
	MovableFigure figure = null;

	/** place from which we read files */
	public String fileName;	
	
	public MisDrawable(MisFigure mf) {
	    super(mf);
	}

    public MisContext getMyContext() {
        return myContext;
    }

    public void setMyContext(MisContext myContext) {
        this.myContext = myContext;
    }
	
    public List<Point> getApnts() {
        return apnts;
    }
	/**
	 * turning 90 degrees clockwise
	 */
	public void turn() {
        Point oldPos = new Point(0,0,0);
        oldPos.set(fig.getPos());
        
        for (Point p : pnts) {
            float t = p.x;
            p.x = -p.y;
            p.y = t;
        }
        for (Point p : apnts) {
            float t = p.x;
            p.x = -p.y;
            p.y = t;
        }
        this.setSizes();
        this.fig.getPos().set(oldPos);
        this.fillBuffers();
	}
	
	/**
	 * read figure configuration from XML.
	 * We can read some configuration in MisFigure.
	 * Actual figure was generated by 
	 * Reading type and pos - anything else we read in derived classes.
	 * 
	 * @param node - XmlNode from which we read configuration
	 */
	public void readXml(Element el) {
		super.readXml(el);	
	}

    public void fillData(MisContext context) {
        this.myContext = context;
    }   
	
	/**
	 * fill texture or buffers or arrays 
	 */
	public abstract void fillBuffers();
	
	public void clean() {
	    // do nothing
	}
	
	/**
	 * draw figure on GL11 surface.
	 */
	public abstract void draw(MisGL11 gl);
    
    /**
     * shift zero so 
     */
    protected void shiftZero(float dx, float dy, float dz) {
        for (Point p : pnts) {
            p.translate(dx, dy, dz);
        }
        for (Point p : apnts) {
            p.translate(dx, dy, dz);
        }
        fig.getPos().translate(-dx, -dy, -dz);        
    }
    
    public void setSizes() {
        float minX, minY, minZ;
        float maxX, maxY, maxZ;
        
        minX = minY = minZ = 10000000;
        maxX = maxY = maxZ = -10000000;
        
        for (Point p : pnts) {
            minX = Math.min(p.x, minX);
            minY = Math.min(p.y, minY);
            minZ = Math.min(p.z, minZ);
            maxX = Math.max(p.x, maxX);
            maxY = Math.max(p.y, maxY);
            maxZ = Math.max(p.z, maxZ);
        }
        sz.x = maxX - minX;
        sz.y = maxY - minY;
        sz.z = maxZ - minZ;
        this.shiftZero(-minX, -minY, -minZ);
    }
    
    public void copy(Box b) {
        super.copy(b);
        MisDrawable md = (MisDrawable)b;
        int np = pnts.size();
        int nt = tris.size();
        
        // copy pnts
        pnts.clear();
        for (int i=0; i < np; i++) {
            Point bp = md.pnts.get(i);
            Point p = new Point(bp.x, bp.y, bp.z);
            pnts.add(p);
        }
        // copy tris
        tris.clear();
        for (int i=0; i < nt; i++) {
            Triangle bt = md.tris.get(i);
            Triangle t = new Triangle(bt.a, bt.b, bt.c);
            tris.add(t);
        }
        this.fileName = md.fileName;
        this.useTextures = md.useTextures;
    }

}
