<!DOCTYPE html>
<!-- saved from url=(0043)http://talks.golang.org/2012/splash.article -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Go at Google: Language Design in the Service of Software Engineering</title>
    <link type="text/css" rel="stylesheet" href="./Go at Google_ Language Design in the Service of Software Engineering_files/article.css">
    <meta charset="utf-8">
    <script type="text/javascript" async="" src="./Go at Google_ Language Design in the Service of Software Engineering_files/ga.js"></script><script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body>
    <div id="topbar" class="wide">
      <div class="container">
        <div id="heading">Go at Google: Language Design in the Service of Software Engineering
          
        </div>
      </div>
    </div>
    <div id="page" class="wide">
      <div class="container">
        
          <div id="toc">
            
  <ul>
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_1.">Abstract</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_2.">Introduction</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_3.">Go at Google</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_4.">Pain points</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_5.">Dependencies in C and C++</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_6.">Enter Go</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_7.">Dependencies in Go</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_8.">Packages</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_9.">Remote packages</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_10.">Syntax</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_11.">Naming</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_12.">Semantics</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_13.">Concurrency</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_14.">Garbage collection</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_15.">Composition not inheritance</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_16.">Errors</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_17.">Tools</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_18.">Conclusion</a></li>
    
  
    <li><a href="http://talks.golang.org/2012/splash.article#TOC_19.">Summary</a></li>
    
  
  </ul>

          </div>
        

        
          
  <h1 id="TOC_1.">1. Abstract</h1>
  
  
  <p>
    (This is a modified version of the keynote talk given by Rob Pike


    at the SPLASH 2012 conference in Tucson, Arizona, on October 25, 2012.)
  </p>
  

  
  <p>
    The Go programming language was conceived in late 2007 as an answer to


    some of the problems we were seeing developing software infrastructure


    at Google.


    The computing landscape today is almost unrelated to the environment


    in which the languages being used, mostly C++, Java, and Python, had


    been created.


    The problems introduced by multicore processors, networked systems,


    massive computation clusters, and the web programming model were being


    worked around rather than addressed head-on.


    Moreover, the scale has changed: today's server programs comprise tens


    of millions of lines of code, are worked on by hundreds or even


    thousands of programmers, and are updated literally every day.


    To make matters worse, build times, even on large compilation


    clusters, have stretched to many minutes, even hours.
  </p>
  

  
  <p>
    Go was designed and developed to make working in this environment more


    productive.


    Besides its better-known aspects such as built-in concurrency and


    garbage collection, Go's design considerations include rigorous


    dependency management, the adaptability of software architecture as


    systems grow, and robustness across the boundaries between components.
  </p>
  

  
  <p>
    This article explains how these issues were addressed while building


    an efficient, compiled programming language that feels lightweight and


    pleasant.


    Examples and explanations will be taken from the real-world problems


    faced at Google.
  </p>
  


        
          
  <h1 id="TOC_2.">2. Introduction</h1>
  
  
  <p>
    Go is a compiled, concurrent, garbage-collected, statically typed language


    developed at Google.


    It is an open source project: Google


    imports the public repository rather than the other way around.
  </p>
  

  
  <p>
    Go is efficient, scalable, and productive. Some programmers find it fun


    to work in; others find it unimaginative, even boring.


    In this article we


    will explain why those are not contradictory positions.


    Go was designed to address the problems faced in software development


    at Google, which led to a language that is not a breakthrough research language


    but is nonetheless an excellent tool for engineering large software projects.
  </p>
  


        
          
  <h1 id="TOC_3.">3. Go at Google</h1>
  
  
  <p>
    Go is a programming language designed by Google to help solve Google's problems, and Google has big problems.
  </p>
  

  
  <p>
    The hardware is big and the software is big.


    There are many millions of lines of software, with servers mostly in C++


    and lots of Java and Python for the other pieces.


    Thousands of engineers work on the code,


    at the "head" of a single tree comprising all the software,


    so from day to day there are significant changes to all levels of the tree.


    A large


    <a href="http://google-engtools.blogspot.com/2011/06/build-in-cloud-accessing-source-code.html" target="_blank">custom-designed distributed build system</a>


    makes development at this scale feasible, but it's still big.
  </p>
  

  
  <p>
    And of course, all this software runs on zillions of machines, which are treated as a modest number of independent, networked compute clusters.
  </p>
  

<div class="image">
  <img src="./Go at Google_ Language Design in the Service of Software Engineering_files/datacenter.jpg">
</div>

  
  <p>
    In short, development at Google is big, can be slow, and is often clumsy. But it <i>is</i> effective.
  </p>
  

  
  <p>
    The goals of the Go project were to eliminate the slowness and clumsiness of software development at Google,


    and thereby to make the process more productive and scalable.


    The language was designed by and for people who write—and read and debug and maintain—large software systems.
  </p>
  

  
  <p>
    Go's purpose is therefore <i>not</i> to do research into programming language design;


    it is to improve the working environment for its designers and their coworkers.


    Go is more about software engineering than programming language research.


    Or to rephrase, it is about language design in the service of software engineering.
  </p>
  

  
  <p>
    But how can a language help software engineering?


    The rest of this article is an answer to that question.
  </p>
  


        
          
  <h1 id="TOC_4.">4. Pain points</h1>
  
  
  <p>
    When Go launched, some claimed it was missing particular features or methodologies that were regarded as <i>de rigueur</i> for a modern language.


    How could Go be worthwhile in the absence of these facilities?


    Our answer to that is that the properties Go <i>does</i> have address the issues that make large-scale software development difficult.


    These issues include:
  </p>
  

  <ul>
  
    <li>slow builds</li>
  
    <li>uncontrolled dependencies</li>
  
    <li>each programmer using a different subset of the language</li>
  
    <li>poor program understanding (code hard to read, poorly documented, and so on)</li>
  
    <li>duplication of effort</li>
  
    <li>cost of updates</li>
  
    <li>version skew</li>
  
    <li>difficulty of writing automatic tools</li>
  
    <li>cross-language builds</li>
  
  </ul>

  
  <p>
    Individual features of a language don't address these issues.


    A larger view of software engineering is required, and


    in the design of Go we tried to focus on solutions to <i>these</i> problems.
  </p>
  

  
  <p>
    As a simple, self-contained example, consider the representation of program structure.


    Some observers objected to Go's C-like block structure with braces, preferring the use of spaces for indentation, in the style of Python or Haskell.


    However, we have had extensive experience tracking down build and test failures caused by cross-language builds where a Python snippet embedded in another language,


    for instance through a SWIG invocation,


    is subtly and <i>invisibly</i> broken by a change in the indentation of the surrounding code.


    Our position is therefore that, although spaces for indentation is nice for small programs, it doesn't scale well,


    and the bigger and more heterogeneous the code base, the more trouble it can cause.


    It is better to forgo convenience for safety and dependability, so Go has brace-bounded blocks.
  </p>
  


        
          
  <h1 id="TOC_5.">5. Dependencies in C and C++</h1>
  
  
  <p>
    A more substantial illustration of scaling and other issues arises in the handling of package dependencies.


    We begin the discussion with a review of how they work in C and C++.
  </p>
  

  
  <p>
    ANSI C, first standardized in 1989, promoted the idea of  <code>#ifndef</code> "guards" in the standard header files.


    The idea, which is ubiquitous now, is that each header file be bracketed with a conditional compilation clause so that the file may be included multiple times without error.


    For instance, the Unix header file <code>&lt;sys/stat.h&gt;</code> looks schematically like this:
  </p>
  

  
  <div class="code"><pre>/* Large copyright and licensing notice */
#ifndef _SYS_STAT_H_
#define _SYS_STAT_H_
/* Types and other definitions */
#endif</pre></div>
  

  
  <p>
    The intent is that the C preprocessor reads in the file but disregards the contents on


    the second and subsequent


    readings of the file.


    The symbol <code>_SYS_STAT_H_</code>, defined the first time the file is read, "guards" the invocations that follow.
  </p>
  

  
  <p>
    This design has some nice properties, most important that each header file can safely <code>#include</code>


    all its dependencies, even if other header files will also include them.


    If that rule is followed, it permits orderly code that, for instance, sorts the <code>#include</code>


    clauses alphabetically.
  </p>
  

  
  <p>
    But it scales very badly.
  </p>
  

  
  <p>
    In 1984, a compilation of <code>ps.c</code>, the source to the Unix <code>ps</code> command, was observed


    to <code>#include</code> <code>&lt;sys/stat.h&gt;</code> 37 times by the time all the preprocessing had been done.


    Even though the contents are discarded 36 times while doing so, most C


    implementations would open the file, read it, and scan it all 37 times.


    Without great cleverness, in fact, that behavior is required by the potentially


    complex macro semantics of the C preprocessor.
  </p>
  

  
  <p>
    The effect on software is the gradual accumulation of <code>#include</code> clauses in C programs.


    It won't break a program to add them, and it's very hard to know when they are no


    longer needed.


    Deleting a <code>#include</code> and compiling the program again isn't even sufficient to test that,


    since another <code>#include</code> might itself contain a <code>#include</code> that pulls it in anyway.
  </p>
  

  
  <p>
    Technically speaking, it does not have to be like that.


    Realizing the long-term problems with the use of <code>#ifndef</code> guards, the designers


    of the Plan 9 libraries took a different, non-ANSI-standard approach.


    In Plan 9, header files were forbidden from containing further <code>#include</code> clauses; all


    <code>#includes</code> were required to be in the top-level C file.


    This required some discipline, of course—the programmer was required to list


    the necessary dependencies exactly once, in the correct order—but documentation


    helped and in practice it worked very well.


    The result was that, no matter how many dependencies a C source file had,


    each <code>#include</code> file was read exactly once when compiling that file.


    And, of course, it was also easy to see if an <code>#include</code> was necessary by taking


    it out: the edited program would compile if and only if the dependency was unnecessary.
  </p>
  

  
  <p>
    The most important result of the Plan 9 approach was much faster compilation: the amount of


    I/O the compilation requires can be dramatically less than when compiling a program


    using libraries with <code>#ifndef</code> guards.
  </p>
  

  
  <p>
    Outside of Plan 9, though, the "guarded" approach is accepted practice for C and C++.


    In fact, C++ exacerbates the problem by using the same approach at finer granularity.


    By convention, C++ programs are usually structured with one header file per class, or perhaps


    small set of related classes, a grouping much smaller than, say, <code>&lt;stdio.h&gt;</code>.


    The dependency tree is therefore much more intricate, reflecting not library dependencies but the full type hierarchy.


    Moreover, C++ header files usually contain real code—type, method, and template


    declarations—not just the simple constants and function signatures typical of a C header file.


    Thus not only does C++ push more to the compiler, what it pushes is harder to compile,


    and each invocation of the compiler must reprocess this information.


    When building a large C++ binary, the compiler might be taught thousands of times how to


    represent a string by processing the header file <code>&lt;string&gt;</code>.


    (For the record, around 1984 Tom Cargill observed that the use of the


    C preprocessor for dependency management would be a long-term liability for C++ and


    should be addressed.)
  </p>
  

  
  <p>
    The construction of a single C++ binary at Google can open and read hundreds of individual header files


    tens of thousands of times.


    In 2007, build engineers at Google instrumented the compilation of a major Google binary.


    The file contained about two thousand files that, if simply concatenated together, totaled 4.2 megabytes.


    By the time the <code>#includes</code> had been expanded, over 8 gigabytes were being delivered to the input of the compiler, a blow-up of 2000 bytes for every C++ source byte.
  </p>
  

  
  <p>
    As another data point, in 2003 Google's build system was moved from a single Makefile to a per-directory design


    with better-managed, more explicit dependencies.


    A typical binary shrank about 40% in file size, just from having more accurate dependencies recorded.


    Even so, the properties of C++ (or C for that matter) make it impractical to verify those dependencies automatically,


    and today we still do not have an accurate understanding of the dependency requirements


    of large Google C++ binaries.
  </p>
  

  
  <p>
    The consequence of these uncontrolled dependencies and massive scale is that it is


    impractical to build Google server binaries on a single computer, so


    a large distributed compilation system was created.


    With this system, involving many machines, much caching, and


    much complexity (the build system is a large program in its own right), builds at


    Google are practical, if still cumbersome.
  </p>
  

  
  <p>
    Even with the distributed build system, a large Google build can still take many minutes.


    That 2007 binary took 45 minutes using a precursor distributed build system; today's


    version of the same program takes 27 minutes, but of course the program and its


    dependencies have grown in the interim.


    The engineering effort required to scale up the build system has barely been able


    to stay ahead of the growth of the software it is constructing.
  </p>
  


        
          
  <h1 id="TOC_6.">6. Enter Go</h1>
  
  
  <p>
    When builds are slow, there is time to think.


    The origin myth for Go states that it was during one of those 45 minute builds


    that Go was conceived. It was believed to be worth trying to design a new language


    suitable for writing large Google programs such as web servers,


    with software engineering considerations that would improve the quality


    of life of Google programmers.
  </p>
  

  
  <p>
    Although the discussion so far has focused on dependencies,


    there are many other issues that need attention.


    The primary considerations for any language to succeed in this context are:
  </p>
  

  <ul>
  
    <li>It must work at scale, for large programs with large numbers of dependencies, with large teams of programmers working on them.</li>
  
  </ul>

  <ul>
  
    <li>It must be familiar, roughly C-like. Programmers working at Google are early in their careers and are most familiar with procedural languages, particularly from the C family. The need to get programmers productive quickly in a new language means that the language cannot be too radical.</li>
  
  </ul>

  <ul>
  
    <li>It must be modern. C, C++, and to some extent Java are quite old, designed before the advent of multicore machines, networking, and web application development. There are features of the modern world that are better met by newer approaches, such as built-in concurrency.</li>
  
  </ul>

  
  <p>
    With that background, then, let us look at the design of Go from a software engineering perspective.
  </p>
  


        
          
  <h1 id="TOC_7.">7. Dependencies in Go</h1>
  
  
  <p>
    Since we've taken a detailed look at dependencies in C and C++, a good place to start


    our tour is to see how Go handles them.


    Dependencies are defined, syntactically and semantically, by the language.


    They are explicit, clear, and "computable", which is to say, easy to write tools to analyze.
  </p>
  

  
  <p>
    The syntax is that, after the <code>package</code> clause (the subject of the next section),


    each source file may have one or more import statements, comprising the


    <code>import</code> keyword and a string constant identifying the package to be imported


    into this source file (only):
  </p>
  

  
  <div class="code"><pre>import "encoding/json"</pre></div>
  

  
  <p>
    The first step to making Go scale, dependency-wise, is that the <i>language</i> defines


    that unused dependencies are a compile-time error (not a warning, an <i>error</i>).


    If the source file imports a package it does not use, the program will not compile.


    This guarantees by construction that the dependency tree for any Go program


    is precise, that it has no extraneous edges. That, in turn, guarantees that no


    extra code will be compiled when building the program, which minimizes


    compilation time.
  </p>
  

  
  <p>
    There's another step, this time in the implementation of the compilers, that


    goes even further to guarantee efficiency.


    Consider a Go program with three packages and this dependency graph:
  </p>
  

  <ul>
  
    <li> package <code>A</code> imports package <code>B</code>;</li>
  
    <li> package <code>B</code> imports package <code>C</code>;</li>
  
    <li> package <code>A</code> does <i>not</i> import package <code>C</code></li>
  
  </ul>

  
  <p>
    This means that package <code>A</code> uses <code>C</code> only transitively through its use of <code>B</code>;


    that is, no identifiers from <code>C</code> are mentioned in the source code to <code>A</code>,


    even if some of the items <code>A</code> is using from <code>B</code> do mention <code>C</code>.


    For instance, package <code>A</code> might reference a  <code>struct</code> type defined in <code>B</code> that has a field with


    a type defined in <code>C</code> but that <code>A</code> does not reference itself.


    As a motivating example, imagine that <code>A</code> imports a formatted I/O package


    <code>B</code> that uses a buffered I/O implementation provided by <code>C</code>, but that <code>A</code> does


    not itself invoke buffered I/O.
  </p>
  

  
  <p>
    To build this program, first, <code>C</code> is compiled;


    dependent packages must be built before the packages that depend on them.


    Then <code>B</code> is compiled; finally <code>A</code> is compiled, and then the program can be linked.
  </p>
  

  
  <p>
    When <code>A</code> is compiled, the compiler reads the object file for <code>B</code>, not its source code.


    That object file for <code>B</code> contains all the type information necessary for the compiler


    to execute the
  </p>
  

  
  <div class="code"><pre>import "B"</pre></div>
  

  
  <p>
    clause in the source code for <code>A</code>. That information includes whatever information


    about <code>C</code> that clients of <code>B</code> will need at compile time.


    In other words, when <code>B</code> is compiled, the generated object file includes type


    information for all dependencies of <code>B</code> that affect the public interface of <code>B</code>.
  </p>
  

  
  <p>
    This design has the important


    effect that when the compiler executes an import clause,


    <i>it opens exactly one file</i>, the object file identified by the string in the import clause.


    This is, of course, reminiscent of the Plan 9 C (as opposed to ANSI C)


    approach to dependency management, except that, in effect, the compiler


    writes the header file when the Go source file is compiled.


    The process is more automatic and even


    more efficient than in Plan 9 C, though: the data being read when evaluating the import is just


    "exported" data, not general program source code. The effect on overall


    compilation time can be huge, and scales well as


    the code base grows. The time to execute the dependency graph, and


    hence to compile, can be exponentially less than in the "include of


    include file" model of C and C++.
  </p>
  

  
  <p>
    It's worth mentioning that this general approach to dependency management


    is not original; the ideas go back to the 1970s and flow through languages like


    Modula-2 and Ada. In the C family Java has elements of this approach.
  </p>
  

  
  <p>
    To make compilation even more efficient, the object file is arranged so the export


    data is the first thing in the file, so the compiler can stop reading as soon


    as it reaches the end of that section.
  </p>
  

  
  <p>
    This approach to dependency management is the single biggest reason


    why Go compilations are faster than C or C++ compilations.


    Another factor is that Go places the export data in the object file; some


    languages require the author to write or the compiler to


    generate a second file with that information. That's twice as many files


    to open. In Go there is only one file to open to import a package.


    Also, the single file approach means that the export data (or header


    file, in C/C++) can never go out of date relative to the object file.
  </p>
  

  
  <p>
    For the record, we measured the compilation of a large Google program


    written in Go to see how the source code fanout compared to the C++


    analysis done earlier. We found it was about 40X, which is


    fifty times better than C++ (as well as being simpler and hence faster


    to process), but it's still bigger than we expected. There are two reasons for


    this. First, we found a bug: the Go compiler was generating a substantial


    amount of data in the export section that did not need to be there. Second,


    the export data uses a verbose encoding that could be improved.


    We plan to address these issues.
  </p>
  

  
  <p>
    Nonetheless, a factor of fifty less to do turns minutes into seconds,


    coffee breaks into interactive builds.
  </p>
  

  
  <p>
    Another feature of the Go dependency graph is that it has no cycles.


    The language defines that there can be no circular imports in the graph,


    and the compiler and linker both check that they do not exist.


    Although they are occasionally useful, circular imports introduce


    significant problems at scale.


    They require the compiler to deal with larger sets of source files


    all at once, which slows down incremental builds.


    More important, when allowed, in our experience such imports end up


    entangling huge swaths of the source tree into large subpieces that are


    difficult to manage independently, bloating binaries and complicating


    initialization, testing, refactoring, releasing, and other tasks of


    software development.
  </p>
  

  
  <p>
    The lack of circular imports causes occasional annoyance but keeps the tree clean,


    forcing a clear demarcation between packages. As with many of the


    design decisions in Go, it forces the programmer to think earlier about a


    larger-scale issue (in this case, package boundaries) that if left until


    later may never be addressed satisfactorily.
  </p>
  

  
  <p>
    Through the design of the standard library, great effort was spent on controlling


    dependencies. It can be better to copy a little code than to pull in a big


    library for one function. (A test in the system build complains if new core


    dependencies arise.) Dependency hygiene trumps code reuse.


    One example of this in practice is that


    the (low-level) <code>net</code> package has its own integer-to-decimal conversion routine


    to avoid depending on the bigger and dependency-heavy formatted I/O package.


    Another is that the string conversion package <code>strconv</code> has a private implementation


    of the definition of 'printable' characters rather than pull in the large Unicode


    character class tables; that <code>strconv</code> honors the Unicode standard is verified by the


    package's tests.
  </p>
  


        
          
  <h1 id="TOC_8.">8. Packages</h1>
  
  
  <p>
    The design of Go's package system combines some of the properties of libraries,


    name spaces, and modules into a single construct.
  </p>
  

  
  <p>
    Every Go source file, for instance <code>"encoding/json/json.go"</code>, starts with a package clause, like this:
  </p>
  

  
  <div class="code"><pre>package json</pre></div>
  

  
  <p>
    where <code>json</code> is the "package name", a simple identifier.


    Package names are usually concise.
  </p>
  

  
  <p>
    To use a package, the importing source file identifies it by its <i>package path</i>


    in the import clause.


    The meaning of "path" is not specified by the language, but in


    practice and by convention it is the slash-separated directory path of the


    source package in the repository, here:
  </p>
  

  
  <div class="code"><pre>import "encoding/json"</pre></div>
  

  
  <p>
    Then the package name (as distinct from path) is used to qualify items from


    the package in the importing source file:
  </p>
  

  
  <div class="code"><pre>var dec = json.NewDecoder(reader)</pre></div>
  

  
  <p>
    This design provides clarity.


    One may always tell whether a name is local to package from its syntax: <code>Name</code> vs. <code>pkg.Name</code>.


    (More on this later.)
  </p>
  

  
  <p>
    For our example, the package path is <code>"encoding/json"</code> while the package name is <code>json</code>.


    Outside the standard repository, the convention is to place the 


    project or company name at the root of the name space:
  </p>
  

  
  <div class="code"><pre>import "google/base/go/log"</pre></div>
  

  
  <p>
    It's important to recognize that package <i>paths</i> are unique,


    but there is no such requirement for package <i>names</i>.


    The path must uniquely identify the package to be imported, while the


    name is just a convention for how clients of the package can refer to its


    contents.


    The package name need not be unique and can be overridden


    in each importing source file by providing a local identifier in the


    import clause. These two imports both reference packages that


    call themselves <code>package</code> <code>log</code>, but to import them in a single source


    file one must be (locally) renamed:
  </p>
  

  
  <div class="code"><pre>import "log"                          // Standard package
import googlelog "google/base/go/log" // Google-specific package</pre></div>
  

  
  <p>
    Every company might have its own <code>log</code> package but


    there is no need to make the package name unique.


    Quite the opposite: Go style suggests keeping package names short and clear


    and obvious in preference to worrying about collisions.
  </p>
  

  
  <p>
    Another example: there are many <code>server</code> packages in Google's code base.
  </p>
  


        
          
  <h1 id="TOC_9.">9. Remote packages</h1>
  
  
  <p>
    An important property of Go's package system is that the package path,


    being in general an arbitrary string, can be co-opted to refer to remote


    repositories by having it identify the URL of the site serving the repository.
  </p>
  

  
  <p>
    Here is how to use the <code>doozer</code> package from <code>github</code>. The <code>go</code> <code>get</code> command


    uses the <code>go</code> build tool to fetch the repository from the site and install it.


    Once installed, it can be imported and used like any regular package.
  </p>
  

  
  <div class="code"><pre>$ go get github.com/4ad/doozer // Shell command to fetch package

import "github.com/4ad/doozer" // Doozer client's import statement

var client doozer.Conn         // Client's use of package</pre></div>
  

  
  <p>
    It's worth noting that the <code>go</code> <code>get</code> command downloads dependencies


    recursively, a property made possible only because the dependencies are


    explicit.


    Also, the allocation of the space of import paths is delegated to URLs,


    which makes the naming of packages decentralized and therefore scalable,


    in contrast to centralized registries used by other languages.
  </p>
  


        
          
  <h1 id="TOC_10.">10. Syntax</h1>
  
  
  <p>
    Syntax is the user interface of a programming language. Although it has


    limited effect on the semantics of the language, which is arguably the


    more important component, syntax determines the readability and hence


    clarity of the language. Also, syntax is critical to tooling: if the language


    is hard to parse, automated tools are hard to write.
  </p>
  

  
  <p>
    Go was therefore designed with clarity and tooling in mind, and has


    a clean syntax.


    Compared to other languages in the C family, its


    grammar is modest in size, with only 25 keywords (C99 has


    37; C++11 has 84; the numbers continue to grow).


    More important,


    the grammar is regular and therefore easy to parse (mostly; there


    are a couple of quirks we might have fixed but didn't discover early


    enough).


    Unlike C and Java and especially C++, Go can be parsed without


    type information or a symbol table;


    there is no type-specific context. The grammar is


    easy to reason about and therefore tools are easy to write.
  </p>
  

  
  <p>
    One of the details of Go's syntax that surprises C programmers is that


    the declaration syntax is closer to Pascal's than to C's.


    The declared name appears before the type and there are more keywords:
  </p>
  

  
  <div class="code"><pre>var fn func([]int) int
type T struct { a, b int }</pre></div>
  

  
  <p>
    as compared to C's
  </p>
  

  
  <div class="code"><pre>int (*fn)(int[]);
struct T { int a, b; }</pre></div>
  

  
  <p>
    Declarations introduced by keyword are easier to parse both for people and


    for computers, and having the type syntax not be the expression syntax


    as it is in C has a significant effect on parsing: it adds grammar


    but eliminates ambiguity.


    But there is a nice side effect, too: for initializing declarations,


    one can drop the <code>var</code> keyword and just take the type of the variable


    from that of the expression. These two declarations are equivalent;


    the second is shorter and idiomatic:
  </p>
  

  
  <div class="code"><pre>var buf *bytes.Buffer = bytes.NewBuffer(x) // explicit
buf := bytes.NewBuffer(x)                  // derived</pre></div>
  

  
  <p>
    There is a blog post at <a href="http://golang.org/s/decl-syntax" target="_blank">golang.org/s/decl-syntax</a> with more detail about the syntax of declarations in Go and


    why it is so different from C.
  </p>
  

  
  <p>
    Function syntax is straightforward for simple functions.


    This example declares the function  <code>Abs</code>, which accepts a single


    variable <code>x</code> of type <code>T</code> and returns a single <code>float64</code> value:
  </p>
  

  
  <div class="code"><pre>func Abs(x T) float64</pre></div>
  

  
  <p>
    A method is just a function with a special parameter, its <i>receiver</i>,


    which can be passed to the function using the standard "dot" notation.


    Method declaration syntax places the receiver in parentheses before the


    function name. Here is the same function, now as a method of type <code>T</code>:
  </p>
  

  
  <div class="code"><pre>func (x T) Abs() float64</pre></div>
  

  
  <p>
    And here is a variable (closure) with a type <code>T</code> argument; Go has first-class


    functions and closures:
  </p>
  

  
  <div class="code"><pre>negAbs := func(x T) float64 { return -Abs(x) }</pre></div>
  

  
  <p>
    Finally, in Go functions can return multiple values. A common case is to


    return the function result and an <code>error</code> value as a pair, like this:
  </p>
  

  
  <div class="code"><pre>func ReadByte() (c byte, err error)

c, err := ReadByte()
if err != nil { ... }</pre></div>
  

  
  <p>
    We'll talk more about errors later.
  </p>
  

  
  <p>
    One feature missing from Go is that it


    does not support default function arguments. This was a deliberate


    simplification. Experience tells us that defaulted arguments make it


    too easy to patch over API design flaws by adding more arguments,


    resulting in too many arguments with interactions that are


    difficult to disentangle or even understand.


    The lack of default arguments requires more functions or methods to be defined,


    as one function cannot hold the entire interface,


    but that leads to a clearer API that is easier to understand.


    Those functions all need separate names, too, which makes it clear


    which combinations exist, as well as encouraging more


    thought about naming, a critical aspect of clarity and readability.
  </p>
  

  
  <p>
    One mitigating factor for the lack of default arguments is that Go


    has easy-to-use, type-safe support for variadic functions.
  </p>
  


        
          
  <h1 id="TOC_11.">11. Naming</h1>
  
  
  <p>
    Go takes an unusual approach to defining the <i>visibility</i> of an identifier,


    the ability for a client of a package to use the item named by the identifier.


    Unlike, for instance, <code>private</code> and <code>public</code> keywords, in Go the name itself


    carries the information: the case of the initial letter of the identifier


    determines the visibility. If the initial character is an upper case letter,


    the identifier is <i>exported</i> (public); otherwise it is not:
  </p>
  

  <ul>
  
    <li>upper case initial letter: <code>Name</code> is visible to clients of package</li>
  
    <li>otherwise: <code>name</code> (or <code>_Name</code>) is not visible to clients of package</li>
  
  </ul>

  
  <p>
    This rule applies to variables, types, functions, methods, constants, fields...


    everything. That's all there is to it.
  </p>
  

  
  <p>
    This was not an easy design decision.


    We spent over a year struggling to


    define the notation to specify an identifier's visibility.


    Once we settled on using the case of the name, we soon realized it had


    become one of the most important properties about the language.


    The name is, after all, what clients of the package use; putting


    the visibility in the name rather than its type means that it's always


    clear when looking at an identifier whether it is part of the public API.


    After using Go for a while, it feels burdensome when going back to


    other languages that require looking up the declaration to discover


    this information.
  </p>
  

  
  <p>
    The result is, again, clarity: the program source text expresses the


    programmer's meaning simply.
  </p>
  

  
  <p>
    Another simplification is that Go has a very compact scope hierarchy:
  </p>
  

  <ul>
  
    <li>universe (predeclared identifiers such as <code>int</code> and <code>string</code>)</li>
  
    <li>package (all the source files of a package live at the same scope)</li>
  
    <li>file (for package import renames only; not very important in practice)</li>
  
    <li>function (the usual)</li>
  
    <li>block (the usual)</li>
  
  </ul>

  
  <p>
    There is no scope for name space or class or other wrapping


    construct. Names come from very few places in Go, and all names


    follow the same scope hierarchy: at any given location in the source,


    an identifier denotes exactly one language object, independent of how


    it is used. (The only exception is statement labels, the targets of <code>break</code>


    statements and the like; they always have function scope.)
  </p>
  

  
  <p>
    This has consequences for clarity. Notice for instance that methods


    declare an explicit receiver and that it must be used to access fields and


    methods of the type. There is no implicit <code>this</code>. That is, one always


    writes
  </p>
  

  
  <div class="code"><pre>rcvr.Field</pre></div>
  

  
  <p>
    (where rcvr is whatever name is chosen for the receiver variable)


    so all the elements of the type always appear lexically bound to


    a value of the receiver type. Similarly, a package qualifier is always present


    for imported names; one writes <code>io.Reader</code> not <code>Reader</code>.


    Not only is this clear, it frees up the identifier <code>Reader</code> as a useful


    name to be used in any package. There are in fact multiple exported


    identifiers in the standard library with name <code>Reader</code>, or <code>Printf</code>


    for that matter, yet which one is being referred to is always unambiguous.
  </p>
  

  
  <p>
    Finally, these rules combine to guarantee that, other than the top-level


    predefined names such as <code>int</code>, (the first component of) every name is


    always declared in the current package.
  </p>
  

  
  <p>
    In short, names are local. In C, C++, or Java the name <code>y</code> could refer to anything.


    In Go, <code>y</code> (or even <code>Y</code>) is always defined within the package,


    while the interpretation of <code>x.Y</code> is clear: find <code>x</code> locally, <code>Y</code> belongs to it.
  </p>
  

  
  <p>
    These rules provide an important property for scaling because they guarantee


    that adding an exported name to a package can never break a client


    of that package. The naming rules decouple packages, providing


    scaling, clarity, and robustness.
  </p>
  

  
  <p>
    There is one more aspect of naming to be mentioned: method lookup


    is always by name only, not by signature (type) of the method.


    In other words, a single type can never have two methods with the same name.


    Given a method <code>x.M</code>, there's only ever one <code>M</code> associated with <code>x</code>.


    Again, this makes it easy to identify which method is referred to given


    only the name.


    It also makes the implementation of method invocation simple.
  </p>
  


        
          
  <h1 id="TOC_12.">12. Semantics</h1>
  
  
  <p>
    The semantics of Go statements is generally C-like. It is a compiled, statically typed,


    procedural language with pointers and so on. By design, it should feel


    familiar to programmers accustomed to languages in the C family.


    When launching a new language


    it is important that the target audience be able to learn it quickly; rooting Go


    in the C family helps make sure that young programmers, most of whom


    know Java, JavaScript, and maybe C, should find Go easy to learn.
  </p>
  

  
  <p>
    That said, Go makes many small changes to C semantics, mostly in the


    service of robustness. These include:
  </p>
  

  <ul>
  
    <li>there is no pointer arithmetic</li>
  
    <li>there are no implicit numeric conversions</li>
  
    <li>array bounds are always checked</li>
  
    <li>there are no type aliases (after <code>type X int</code>, <code>X</code> and <code>int</code> are distinct types not aliases)</li>
  
    <li><code>++</code> and <code>--</code> are statements not expressions</li>
  
    <li>assignment is not an expression</li>
  
    <li>it is legal (encouraged even) to take the address of a stack variable</li>
  
    <li>and many more</li>
  
  </ul>

  
  <p>
    There are some much bigger changes too, stepping far from the traditional


    C, C++, and even Java models. These include linguistic support for:
  </p>
  

  <ul>
  
    <li>concurrency</li>
  
    <li>garbage collection</li>
  
    <li>interface types</li>
  
    <li>reflection</li>
  
    <li>type switches</li>
  
  </ul>

  
  <p>
    The following sections provide brief discussions of two of these topics in Go,


    concurrency and garbage collection,


    mostly from a software engineering perspective.


    For a full discussion of the language semantics and uses see the many


    resources on the <a href="http://golang.org/" target="_blank">golang.org</a> web site.
  </p>
  


        
          
  <h1 id="TOC_13.">13. Concurrency</h1>
  
  
  <p>
    Concurrency is important to the modern computing environment with its


    multicore machines running web servers with multiple clients,


    what might be called the typical Google program.


    This kind of software is not especially well served by C++ or Java,


    which lack sufficient concurrency support at the language level.
  </p>
  

  
  <p>
    Go embodies a variant of CSP with first-class channels.


    CSP was chosen partly due to familiarity (one of us had worked on


    predecessor languages that built on CSP's ideas), but also because


    CSP has the property that it is easy to add to a procedural programming


    model without profound changes to that model.


    That is, given a C-like language, CSP can be added to the language


    in a mostly orthogonal way, providing extra expressive power without


    constraining the language's other uses. In short, the rest of the


    language can remain "ordinary".
  </p>
  

  
  <p>
    The approach is thus the composition of independently executing


    functions of otherwise regular procedural code.
  </p>
  

  
  <p>
    The resulting language allows us to couple concurrency with computation


    smoothly. Consider a web server that must verify security certificates for


    each incoming client call; in Go it is easy to construct the software using


    CSP to manage the clients as independently executing procedures but


    to have the full power of an efficient compiled language available for


    the expensive cryptographic calculations.
  </p>
  

  
  <p>
    In summary, CSP is practical for Go and for Google. When writing


    a web server, the canonical Go program, the model is a great fit.
  </p>
  

  
  <p>
    There is one important caveat: Go is not purely memory safe in the presence


    of concurrency. Sharing is legal and passing a pointer over a channel is idiomatic


    (and efficient).
  </p>
  

  
  <p>
    Some concurrency and functional programming experts are disappointed


    that Go does not take a write-once approach to value semantics


    in the context of concurrent computation, that Go is not more like


    Erlang for example.


    Again, the reason is largely about familiarity and suitability for the


    problem domain. Go's concurrent features work well in a context


    familiar to most programmers.


    Go <i>enables</i> simple, safe concurrent


    programming but does not <i>forbid</i> bad programming.


    We compensate by convention, training programmers to think


    about message passing as a version of ownership control. The motto is,


    "Don't communicate by sharing memory, share memory by communicating."
  </p>
  

  
  <p>
    Our limited experience with programmers new to both Go and concurrent


    programming shows that this is a practical approach. Programmers


    enjoy the simplicity that support for concurrency brings to network


    software, and simplicity engenders robustness.
  </p>
  


        
          
  <h1 id="TOC_14.">14. Garbage collection</h1>
  
  
  <p>
    For a systems language, garbage collection can be a controversial feature,


    yet we spent very little time deciding that Go would be a


    garbage-collected language.


    Go has no explicit memory-freeing operation: the only way allocated


    memory returns to the pool is through the garbage collector.
  </p>
  

  
  <p>
    It was an easy decision to make because memory management


    has a profound effect on the way a language works in practice. 


    In C and C++, too much programming effort is spent on memory allocation


    and freeing.


    The resulting designs tend to expose details of memory management


    that could well be hidden; conversely memory considerations


    limit how they can be used. By contrast, garbage collection makes interfaces


    easier to specify.
  </p>
  

  
  <p>
    Moreover, in a concurrent object-oriented language it's almost essential


    to have automatic memory management because the ownership of a piece


    of memory can be tricky to manage as it is passed around among concurrent


    executions. It's important to separate behavior from resource management.
  </p>
  

  
  <p>
    The language is much easier to use because of garbage collection.
  </p>
  

  
  <p>
    Of course, garbage collection brings significant costs: general overhead,


    latency, and complexity of the implementation. Nonetheless, we believe


    that the benefits, which are mostly felt by the programmer, outweigh


    the costs, which are largely borne by the language implementer.
  </p>
  

  
  <p>
    Experience with Java in particular as a server language has made some


    people nervous about garbage collection in a user-facing system.


    The overheads are uncontrollable, latencies can be large, and much


    parameter tuning is required for good performance.


    Go, however, is different. Properties of the language mitigate some of these


    concerns. Not all of them of course, but some.
  </p>
  

  
  <p>
    The key point is that Go gives the programmer tools to limit allocation


    by controlling the layout of data structures. Consider this simple


    type definition of a data structure containing a buffer (array) of bytes:
  </p>
  

  
  <div class="code"><pre>type X struct {
    a, b, c int
    buf [256]byte
}</pre></div>
  

  
  <p>
    In Java, the <code>buf</code> field would require a second allocation and accesses


    to it a second level of indirection. In Go, however, the buffer is allocated


    in a single block of memory along with the containing struct and no


    indirection is required. For systems programming, this design can have a


    better performance as well as reducing the number


    of items known to the collector. At scale it can make a significant


    difference.
  </p>
  

  
  <p>
    As a more direct example, in Go it is easy and efficient to provide


    second-order allocators, for instance an arena allocator that allocates


    a large array of structs and links them together with a free list.


    Libraries that repeatedly use many small structures like this can,


    with modest prearrangement, generate no garbage yet


    be efficient and responsive.
  </p>
  

  
  <p>
    Although Go is a garbage collected language, therefore, a knowledgeable


    programmer can limit the pressure placed on the collector and thereby


    improve performance. (Also, the Go installation comes with good tools


    for studying the dynamic memory performance of a running program.)
  </p>
  

  
  <p>
    To give the programmer this flexibility, Go must support


    what we call <i>interior pointers</i> to objects


    allocated in the heap. The <code>X.buf</code> field in the example above lives


    within the struct but it is legal to capture the address of this inner field,


    for instance to pass it to an I/O routine. In Java, as in many garbage-collected


    languages, it is not possible to construct an interior pointer like this,


    but in Go it is idiomatic.


    This design point affects which collection algorithms can be used,


    and may make them more difficult, but after careful thought we decided


    that it was necessary to allow interior pointers because of the benefits


    to the programmer and the ability to reduce pressure on the (perhaps


    harder to implement) collector.


    So far, our experience comparing similar Go and Java programs shows


    that use of interior pointers can have a significant effect on total arena size,


    latency, and collection times.
  </p>
  

  
  <p>
    In summary, Go is garbage collected but gives the programmer


    some tools to control collection overhead.
  </p>
  

  
  <p>
    The garbage collector remains an active area of development.


    The current design is a parallel mark-and-sweep collector and there remain


    opportunities to improve its performance or perhaps even its design.


    (The language specification does not mandate any particular implementation


    of the collector.)


    Still, if the programmer takes care to use memory wisely,


    the current implementation works well for production use.
  </p>
  


        
          
  <h1 id="TOC_15.">15. Composition not inheritance</h1>
  
  
  <p>
    Go takes an unusual approach to object-oriented programming, allowing


    methods on any type, not just classes, but without any form of type-based inheritance


    like subclassing.


    This means there is no type hierarchy.


    This was an intentional design choice.


    Although type hierarchies have been used to build much successful


    software, it is our opinion that the model has been overused and that it


    is worth taking a step back.
  </p>
  

  
  <p>
    Instead, Go has <i>interfaces</i>, an idea that has been discussed at length elsewhere (see


    <a href="http://research.swtch.com/interfaces" target="_blank">research.swtch.com/interfaces</a>


    for example), but here is a brief summary.
  </p>
  

  
  <p>
    In Go an interface is <i>just</i> a set of methods. For instance, here is the definition


    of the <code>Hash</code> interface from the standard library.
  </p>
  

  
  <div class="code"><pre>type Hash interface {
    Write(p []byte) (n int, err error)
    Sum(b []byte) []byte
    Reset()
    Size() int
    BlockSize() int
}</pre></div>
  

  
  <p>
    All data types that implement these methods satisfy this interface implicitly;


    there is no <code>implements</code> declaration.


    That said, interface satisfaction is statically checked at compile time


    so despite this decoupling interfaces are type-safe.
  </p>
  

  
  <p>
    A type will usually satisfy many interfaces, each corresponding


    to a subset of its methods. For example, any type that satisfies the <code>Hash</code>


    interface also satisfies the <code>Writer</code> interface:
  </p>
  

  
  <div class="code"><pre>type Writer interface {
    Write(p []byte) (n int, err error)
}</pre></div>
  

  
  <p>
    This fluidity of interface satisfaction encourages a different approach


    to software construction. But before explaining that, we should explain


    why Go does not have subclassing.
  </p>
  

  
  <p>
    Object-oriented programming provides a powerful insight: that the


    <i>behavior</i> of data can be generalized independently of the


    <i>representation</i> of that data.


    The model works best when the behavior (method set) is fixed,


    but once you subclass a type and add a method,


    <i>the behaviors are no longer identical</i>.


    If instead the set of behaviors is fixed, such as in Go's statically


    defined interfaces, the uniformity of behavior enables data and


    programs to be composed uniformly, orthogonally, and safely.
  </p>
  

  
  <p>
    One extreme example is the Plan 9 kernel, in which all system data items


    implemented exactly the same interface, a file system API defined


    by 14 methods.


    This uniformity permitted a level of object composition seldom


    achieved in other systems, even today.


    Examples abound. Here's one: A system could import (in Plan 9 terminology) a TCP


    stack to a computer that didn't have TCP or even Ethernet, and over that network


    connect to a machine with a different CPU architecture, import its <code>/proc</code> tree,


    and run a local debugger to do breakpoint debugging of the remote process.


    This sort of operation was workaday on Plan 9, nothing special at all.


    The ability to do such things fell out of the design; it required no special


    arrangement (and was all done in plain C).
  </p>
  

  
  <p>
    We argue that this compositional style of system construction has been


    neglected by the languages that push for design by type hierarchy.


    Type hierarchies result in brittle code.


    The hierarchy must be designed early, often as the first step of


    designing the program, and early decisions can be difficult to change once


    the program is written.


    As a consequence, the model encourages early overdesign as the


    programmer tries to predict every possible use the software might


    require, adding layers of type and abstraction just in case.


    This is upside down.


    The way pieces of a system interact should adapt as it grows,


    not be fixed at the dawn of time.
  </p>
  

  
  <p>
    Go therefore encourages <i>composition</i> over inheritance, using


    simple, often one-method interfaces to define trivial behaviors


    that serve as clean, comprehensible boundaries between components.
  </p>
  

  
  <p>
    Consider the <code>Writer</code> interface shown above, which is defined in


    package <code>io</code>: Any item that has a <code>Write</code> method with this


    signature works well with the complementary <code>Reader</code> interface:
  </p>
  

  
  <div class="code"><pre>type Reader interface {
    Read(p []byte) (n int, err error)
}</pre></div>
  

  
  <p>
    These two complementary methods allow type-safe chaining


    with rich behaviors, like generalized Unix pipes.


    Files, buffers, networks,


    encryptors, compressors, image encoders, and so on can all be


    connected together.


    The <code>Fprintf</code> formatted I/O routine takes an <code>io.Writer</code> rather than,


    as in C, a <code>FILE*</code>.


    The formatted printer has no knowledge of what it is writing to; it may


    be a image encoder that is in turn writing to a compressor that


    is in turn writing to an encryptor that is in turn writing to a network


    connection.
  </p>
  

  
  <p>
    Interface composition is a different style of programming, and


    people accustomed to type hierarchies need to adjust their thinking to


    do it well, but the result is an adaptability of


    design that is harder to achieve through type hierarchies.
  </p>
  

  
  <p>
    Note too that the elimination of the type hierarchy also eliminates


    a form of dependency hierarchy.


    Interface satisfaction allows the program to grow organically without


    predetermined contracts.


    And it is a linear form of growth; a change to an interface affects


    only the immediate clients of that interface; there is no subtree to update.


    The lack of <code>implements</code> declarations disturbs some people but


    it enables programs to grow naturally, gracefully, and safely.
  </p>
  

  
  <p>
    Go's interfaces have a major effect on program design.


    One place we see this is in the use of functions that take interface


    arguments. These are <i>not</i> methods, they are functions.


    Some examples should illustrate their power.


    <code>ReadAll</code> returns a byte slice (array) holding all the data that can


    be read from an <code>io.Reader</code>:
  </p>
  

  
  <div class="code"><pre>func ReadAll(r io.Reader) ([]byte, error)</pre></div>
  

  
  <p>
    Wrappers—functions that take an interface and return an interface—are


    also widespread.


    Here are some prototypes.


    <code>LoggingReader</code> logs every <code>Read</code> call on the incoming <code>Reader</code>.


    <code>LimitingReader</code> stops reading after <code>n</code> bytes.


    <code>ErrorInjector</code> aids testing by simulating I/O errors.


    And there are many more.
  </p>
  

  
  <div class="code"><pre>func LoggingReader(r io.Reader) io.Reader
func LimitingReader(r io.Reader, n int64) io.Reader
func ErrorInjector(r io.Reader) io.Reader</pre></div>
  

  
  <p>
    The designs are nothing like hierarchical, subtype-inherited methods.


    They are looser (even <i>ad hoc</i>), organic, decoupled, independent, and therefore scalable.
  </p>
  


        
          
  <h1 id="TOC_16.">16. Errors</h1>
  
  
  <p>
    Go does not have an exception facility in the conventional sense,


    that is, there is no control structure associated with error handling.


    (Go does provide mechanisms for handling exceptional situations


    such as division by zero. A pair of built-in functions


    called <code>panic</code> and <code>recover</code> allow the programmer to protect


    against such things. However, these functions


    are intentionally clumsy, rarely used, and not integrated


    into the library the way, say, Java libraries use exceptions.)
  </p>
  

  
  <p>
    The key language feature for error handling is a pre-defined


    interface type called <code>error</code> that represents a value that has an


    <code>Error</code> method returning a string:
  </p>
  

  
  <div class="code"><pre>type error interface {
    Error() string
}</pre></div>
  

  
  <p>
    Libraries use the <code>error</code> type to return a description of the error.


    Combined with the ability for functions to return multiple


    values, it's easy to return the computed result along with an


    error value, if any.


    For instance, the equivalent


    to C's <code>getchar</code> does not return an out-of-band value at EOF,


    nor does it throw an exception; it just returns an <code>error</code> value


    alongside the character, with a <code>nil</code> <code>error</code> value signifying success.


    Here is the signature of the <code>ReadByte</code> method of the buffered


    I/O package's <code>bufio.Reader</code> type:
  </p>
  

  
  <div class="code"><pre>func (b *Reader) ReadByte() (c byte, err error)</pre></div>
  

  
  <p>
    This is a clear and simple design, easily understood.


    Errors are just values and programs compute with


    them as they would compute with values of any other type.
  </p>
  

  
  <p>
    It was a deliberate choice not to incorporate exceptions in Go.


    Although a number of critics disagree with this decision, there


    are several reasons we believe it makes for better software.
  </p>
  

  
  <p>
    First, there is nothing truly exceptional about errors in computer programs.


    For instance, the inability to open a file is a common issue that


    does not deserve special linguistic constructs; <code>if</code> and <code>return</code> are fine.
  </p>
  

  
  <div class="code"><pre>f, err := os.Open(fileName)
if err != nil {
    return err
}</pre></div>
  

  
  <p>
    Also, if errors use special control structures, error handling distorts


    the control flow for a program that handles errors.


    The Java-like style of <code>try-catch-finally</code> blocks interlaces multiple overlapping flows


    of control that interact in complex ways.


    Although in contrast Go makes it more


    verbose to check errors, the explicit design keeps the flow of control


    straightforward—literally.
  </p>
  

  
  <p>
    There is no question the resulting code can be longer,


    but the clarity and simplicity of such code offsets its verbosity.


    Explicit error checking forces the programmer to think about


    errors—and deal with them—when they arise. Exceptions make


    it too easy to <i>ignore</i> them rather than <i>handle</i> them, passing


    the buck up the call stack until it is too late to fix the problem or


    diagnose it well.
  </p>
  


        
          
  <h1 id="TOC_17.">17. Tools</h1>
  
  
  <p>
    Software engineering requires tools.


    Every language operates in an environment with other languages


    and myriad tools to compile, edit, debug, profile, test, and run programs.
  </p>
  

  
  <p>
    Go's syntax, package system, naming conventions, and other features


    were designed to make tools easy to write, and the library


    includes a lexer, parser, and type checker for the language.
  </p>
  

  
  <p>
    Tools to manipulate Go programs are so easy to write that


    many such tools have been created,


    some with interesting consequences for software engineering.
  </p>
  

  
  <p>
    The best known of these is <code>gofmt</code>, the Go source code formatter.


    From the beginning of the project, we  intended Go programs


    to be formatted by machine, eliminating an entire class of argument


    between programmers: how do I lay out my code?


    <code>Gofmt</code> is run on all Go programs we write, and most of the open


    source community uses it too.


    It is run as a "presubmit" check for the code repositories to


    make sure that all checked-in Go programs are formatted the same.
  </p>
  

  
  <p>
    <code>Gofmt</code> is often cited by users as one of Go's best features even


    though it is not part of the language.


    The existence and use of <code>gofmt</code> means that


    from the beginning, the community has always


    seen Go code as <code>gofmt</code> formats it, so Go programs have a single


    style that is now familiar to everyone. Uniform presentation


    makes code easier to read and therefore faster to work on.


    Time not spent on formatting is time saved.


    <code>Gofmt</code> also affects scalability: since all code looks the same,


    teams find it easier to work together or with others' code.
  </p>
  

  
  <p>
    <code>Gofmt</code> enabled another class of tools that we did not foresee as clearly.


    The program works by parsing the source code and reformatting it


    from the parse tree itself.


    This makes it possible to <i>edit</i> the parse tree before formatting it,


    so a suite of automatic refactoring tools sprang up.


    These are easy to write, can be semantically rich because they work


    directly on the parse tree, and automatically produce canonically


    formatted code.
  </p>
  

  
  <p>
    The first example was a <code>-r</code> (rewrite) flag on <code>gofmt</code> itself, which


    uses a simple pattern-matching language to enable expression-level


    rewrites. For instance, one day we introduced a default value for the


    right-hand side of a slice expression: the length itself. The entire


    Go source tree was updated to use this default with the single


    command:
  </p>
  

  
  <div class="code"><pre>gofmt -r 'a[b:len(a)] -&gt; a[b:]'</pre></div>
  

  
  <p>
    A key point about this transformation is that, because the input and


    output are both in the canonical format, the only changes made to


    the source code are semantic ones.
  </p>
  

  
  <p>
    A similar but more intricate process allowed <code>gofmt</code> to be used to


    update the tree when the language no longer required semicolons


    as statement terminators if the statement ended at a newline.
  </p>
  

  
  <p>
    Another important tool is <code>gofix</code>, which runs tree-rewriting modules


    written in Go itself that are therefore are capable of more advanced


    refactorings.


    The <code>gofix</code> tool allowed us to make sweeping changes to APIs and language


    features leading up to the release of Go 1, including a change to the syntax


    for deleting entries from a map, a radically different API for manipulating


    time values, and many more.


    As these changes rolled out, users could update all their code by running


    the simple command
  </p>
  

  
  <div class="code"><pre>gofix</pre></div>
  

  
  <p>
    Note that these tools allow us to <i>update</i> code even if the old code still


    works.


    As a result, Go repositories are easy to keep up to date as libraries evolve.


    Old APIs can be deprecated quickly and automatically so only one version


    of the API needs to be maintained.


    For example, we recently changed Go's protocol buffer implementation to use


    "getter" functions, which were not in the interface before.


    We ran <code>gofix</code> on <i>all</i> of Google's Go code to update all programs that


    use protocol buffers, and now there is only one version of the API in use.


    Similar sweeping changes to the C++ or Java libraries are almost infeasible


    at the scale of Google's code base.
  </p>
  

  
  <p>
    The existence of a parsing package in the standard Go library has enabled


    a number of other tools as well. Examples include the <code>go</code> tool, which


    manages program construction including acquiring packages from


    remote repositories;


    the <code>godoc</code> document extractor,


    a program to verify that the API compatibility contract is maintained as


    the library is updated, and many more.
  </p>
  

  
  <p>
    Although tools like these are rarely mentioned in the context of language


    design, they are an integral part of a language's ecosystem and the fact


    that Go was designed with tooling in mind has a huge effect on the


    development of the language, its libraries, and its community.
  </p>
  


        
          
  <h1 id="TOC_18.">18. Conclusion</h1>
  
  
  <p>
    Go's use is growing inside Google.
  </p>
  

  
  <p>
    Several big user-facing services use it, including <code>youtube.com</code> and <code>dl.google.com</code>


    (the download server that delivers Chrome, Android and other downloads),


    as well as our own <a href="http://golang.org/" target="_blank">golang.org</a>.


    And of course many small ones do, mostly


    built using Google App Engine's native support for Go.
  </p>
  

  
  <p>
    Many other companies use Go as well; the list is very long, but a few of the


    better known are:
  </p>
  

  <ul>
  
    <li>BBC Worldwide</li>
  
    <li>Canonical</li>
  
    <li>Heroku</li>
  
    <li>Nokia</li>
  
    <li>SoundCloud</li>
  
  </ul>

  
  <p>
    It looks like Go is meeting its goals. Still, it's too early to declare it a success.


    We don't have enough experience yet, especially with big programs (millions


    of lines of code) to know whether the attempts to build a scalable language


    have paid off. All the indicators are positive though.
  </p>
  

  
  <p>
    On a smaller scale, some minor things aren't quite right and might get


    tweaked in a later (Go 2?) version of the language. For instance, there are


    too many forms of variable declaration syntax, programmers are


    easily confused by the behavior of nil values inside non-nil interfaces,


    and there are many library and interface details that could use another


    round of design.
  </p>
  

  
  <p>
    It's worth noting, though, that <code>gofix</code> and <code>gofmt</code> gave us the opportunity to


    fix many other problems during the leadup to Go version 1.


    Go as it is today is therefore much closer to what the designers wanted


    than it would have been without these tools, which were themselves


    enabled by the language's design.
  </p>
  

  
  <p>
    Not everything was fixed, though. We're still learning (but the language


    is frozen for now).
  </p>
  

  
  <p>
    A significant weakness of the language is that the implementation still


    needs work. The compilers' generated code and the performance of the


    runtime in particular should be better, and work continues on them.


    There is progress already; in fact some benchmarks show a


    doubling of performance with the development version today compared


    to the first release of Go version 1 early in 2012.
  </p>
  


        
          
  <h1 id="TOC_19.">19. Summary</h1>
  
  
  <p>
    Software engineering guided the design of Go.


    More than most general-purpose


    programming languages, Go was designed to address a set of software engineering


    issues that we had been exposed to in the construction of large server software.


    Offhand, that might make Go sound rather dull and industrial, but in fact


    the focus on clarity, simplicity and composability throughout the design


    instead resulted in a productive, fun language that many programmers


    find expressive and powerful.
  </p>
  

  
  <p>
    The properties that led to that include:
  </p>
  

  <ul>
  
    <li>Clear dependencies</li>
  
    <li>Clear syntax</li>
  
    <li>Clear semantics</li>
  
    <li>Composition over inheritance</li>
  
    <li>Simplicity provided by the programming model (garbage collection, concurrency)</li>
  
    <li>Easy tooling (the <code>go</code> tool, <code>gofmt</code>, <code>godoc</code>, <code>gofix</code>)</li>
  
  </ul>

  
  <p>
    If you haven't tried Go already, we suggest you do.
  </p>
  
<p class="link"><a href="http://golang.org/" target="_blank">http://golang.org</a></p>
<div class="image">
  <img src="./Go at Google_ Language Design in the Service of Software Engineering_files/appenginegophercolor.jpg">
</div>


        

        
          <h2>Authors</h2>
          
            <div class="author">
              
  
  <p>
    Rob Pike
  </p>
  

  
  <p>
    Google, Inc.
  </p>
  
<p class="link"><a href="http://twitter.com/rob_pike" target="_blank">@rob_pike</a></p><p class="link"><a href="http://golang.org/s/plusrob" target="_blank">http://golang.org/s/plusrob</a></p><p class="link"><a href="http://golang.org/" target="_blank">http://golang.org</a></p>
            </div>
          
        
      </div>
    </div>
    <script src="./Go at Google_ Language Design in the Service of Software Engineering_files/play.js"></script>
    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  

</body></html>