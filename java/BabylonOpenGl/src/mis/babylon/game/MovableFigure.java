package mis.babylon.game;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.w3c.dom.Element;

import mis.babylon.game.graphics.MisDrawable;
import mis.babylon.game.graphics.Point;
import mis.babylon.utils.Util;

public class MovableFigure extends MisFigure {
    /**
     * points that can support other figures
     */
    List<Point> supTop = new ArrayList<Point>();
    /**
     * point on which we can support our figure.
     */
    List<Point> supBottom = new ArrayList<Point>();    
    
    /** 
     * list of figures supportiung this figure
     */
    public Set<MovableFigure> supports = new HashSet<MovableFigure>();
    
    /**
     * list of figures that this figure supports.
     */
    public Set<MovableFigure> children = new HashSet<MovableFigure>();

    public int turnsCount = 0;
    public boolean canGrab = true;    
    static int lastIdx = 1;
    World w = null;
    
    public void updateState(long millis) {
        // TODO
    }
    
    public void turn() {
        getDraw().turn();
        turnsCount = (turnsCount + 1) % 4;
    }
    
    String nextName(String name) {
        String []ss = name.split("_");
        String nn = ss[0] + "_" + (lastIdx++);
        return nn;
    }
    
    /**
     * Initialize figure after image is read.
     * for now we will assume one image
     */
    public void init(World w) {
        if (images.size() > 1) {
            throw new IllegalStateException("Many images not implemented yet");
        }
        MisDrawable md = getDraw();
        List<Point> ap = md.getApnts();
        ap.clear();
        for (Point p : supTop) {
            ap.add(p);
        }
        for (Point p : supBottom) {
            ap.add(p);
        }
        int tc = turnsCount;
        for (int it=0; it<tc; it++) {
            turn();
        }
        turnsCount = tc;
        this.w = w;
    }
    
    public MovableFigure makeCopy() {
        MovableFigure mf = (MovableFigure)MisFigure.generateFigure(type);
        mf.copy(this);   
        return mf;
    }
    
    public void copy(MovableFigure bf) {
        this.type = bf.type;
        this.name = nextName(bf.name);
        this.pos.set(bf.getPos());
        this.getDraw().copy(bf.getDraw());
        // copy support points
        Util.copyList(bf.supBottom, supBottom);
        Util.copyList(bf.supTop, supTop);
        this.canGrab = bf.canGrab;
    }
    
    public void addSupport(MovableFigure b) {
        if (!this.getDraw().intersectXY(b.getDraw())) {
            throw new IllegalStateException(
                    "Illegal support " + this.name + " on " +b.name);
        }
        this.supports.add(b);
        b.children.add(this);
    }
    
    public void removeSupports() {
        for (MovableFigure b : supports) {
            b.children.remove(this);
        }
        supports.clear();        
    }
    
    public void removeChildren() {
        for (MovableFigure b : children) {
            b.supports.remove(this);
        }
        children.clear();        
    }
    
    /**
     * read figure configuration from XML.
     * We can read some configuration in MisFigure.
     * Actual figure was generated by 
     * Reading type and pos - anything else we read in derived classes.
     * 
     * @param node - XmlNode from which we read configuration
     */
    public void readXml(Element el) {
        // super.readXml(el);  
        this.name = el.getAttribute("name");
        this.getDraw().readXml(el);
    }
    
    public boolean isSupported() {
        if (type.equals("storage") || type.equals("foundation") || type.equals("garbage")) {
            return true;
        }
        return supports.size() > 0;        
    }
    
    public boolean isAceptableSupport(Cell c) {
        return true;
    }
}
